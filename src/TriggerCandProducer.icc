#include "PhysicsTools/TagAndProbe/interface/TriggerCandProducer.h"
#include <cmath>
#include "DataFormats/Math/interface/deltaR.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include <string>

#include "DataFormats/HLTReco/interface/TriggerObject.h"
#include "FWCore/Framework/interface/TriggerNames.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/HLTReco/interface/TriggerEvent.h"
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"


template<typename C>
TriggerCandProducer<C>::TriggerCandProducer(const edm::ParameterSet& iConfig )
{

  _inputProducer = iConfig.template getParameter<edm::InputTag>("InputProducer");

   // **************** Trigger ******************* //
   const edm::InputTag dTriggerEventTag("hltTriggerSummaryAOD","","HLT8E29");
   triggerEventTag_ = 
      iConfig.getUntrackedParameter<edm::InputTag>("triggerEventTag",
						   dTriggerEventTag);

   const edm::InputTag dHLTTag("HLT_Ele15_LW_L1R", "","HLT8E29");
   hltTag_ = iConfig.getUntrackedParameter<edm::InputTag>("hltTag",dHLTTag);

   delRMatchingCut_ = iConfig.getUntrackedParameter<double>("triggerDelRMatch",
							    0.30);
   // ******************************************** //

   produces<reco::CandidateCollection>();
}


template<typename C>
TriggerCandProducer<C>::~TriggerCandProducer()
{

}


//
// member functions
//


// ------------ method called to produce the data  ------------
template<typename C>
void TriggerCandProducer<C>::produce(edm::Event &event, 
				   const edm::EventSetup &eventSetup)
{

  using namespace std;
  using namespace edm;
  using namespace reco;
  using namespace trigger;


   // Create the output collection
   std::auto_ptr<reco::CandidateCollection> outCol( new reco::CandidateCollection );


   // Get the input collection
   edm::Handle<C> candHandle;
   try
   {
      event.getByLabel(_inputProducer, candHandle);
   }
   catch(cms::Exception &ex)
   {
      edm::LogError("TriggerCandProducer") << "Error! Can't get collection: " << 
	_inputProducer;
      throw ex;
   }

   // Trigger Info
   edm::Handle<trigger::TriggerEvent> trgEvent;
   event.getByLabel(triggerEventTag_,trgEvent);

   // Some sanity checks
   if (not trgEvent.isValid()) {
     edm::LogInfo("info")<< "******** Following Trigger Summary Object Not Found: " << 
       triggerEventTag_;
     event.put(outCol);
     return;
   }

   //---------------------------------------------------------------------------
   /*
   std::string l1pathname;
   HLTConfigProvider hltConfig;
   hltConfig.init(hltTag_.process() );
   std::vector<std::string> filters = hltConfig.moduleLabels( hltTag_.label() );

   for(std::vector<std::string>::iterator filter =
	 filters.begin(); filter!= filters.end(); ++filter ) {

     // cout << hltTag_ << "\t" << *filter << "\t" <<
     //  hltConfig.moduleType(*filter) << endl;
   
     if (hltConfig.moduleType(*filter) == "HLTLevel1GTSeed") {
       
       edm::ParameterSet l1GTPSet = hltConfig.modulePSet(*filter);
       l1GTPSet.getParameter<std::string>("L1SeedsLogicalExpression");
       l1pathname = *filter;
       break;
     }
   }
   */
   //--------------------------------------------------------------------------
   //std::cout << "path name " << l1pathname << std::endl;


   // loop over these objects to see whether they match
   const trigger::TriggerObjectCollection& TOC( trgEvent->getObjects() );
     

   //-----------------------------------------------------------------
   // find how many relevant
   /*
   edm::InputTag l1testTag(l1pathname,"", hltTag_.process() );
   const int index = trgEvent->filterIndex( l1testTag );
   */
   //-----------------------------------------------------------------





   //-----------------------------------------------------------------------
   int index  = trgEvent->sizeFilters();   
   for(int i=0; i != trgEvent->sizeFilters(); ++i) {
     std::string label(trgEvent->filterTag(i).label());
     if( label == hltTag_.label() ) index = i;
   }
   //-----------------------------------------------------------------------




   if( index >= trgEvent->sizeFilters() ) {
     // edm::LogInfo("info")<< "******** Following TRIGGER Name Not in Dataset: " <<
     //  hltTag_.label();
     event.put(outCol);
     return;
   }

   // find how many objects there are
   const trigger::Keys& KEYS(trgEvent->filterKeys(index));
   const size_type nK(KEYS.size());
   // bool l1accept = nK > 0;


   // Loop over the candidate collection
   for(unsigned int i = 0; i < candHandle->size(); ++i) {
     // Get cut decision for each candidate

     reco::CandidateBaseRef masterClone( edm::Ref<C>( candHandle, i ) );

     // Did this tag cause a HLT trigger?
     bool hltTrigger = false;


     for(int ipart = 0; ipart != nK; ++ipart) { 

       const trigger::TriggerObject& TO = TOC[KEYS[ipart]];	
       double dRval = deltaR((float) masterClone->eta(), 
			     (float)masterClone->phi(), 
			     TO.eta(), TO.phi());	
       hltTrigger = dRval < delRMatchingCut_;
 
       if( hltTrigger ) break;
     }       


     if(hltTrigger) outCol->push_back( new reco::ShallowCloneCandidate( masterClone ) );
   } 

   event.put(outCol);
}
   




// ---- method called once each job just before starting event loop  ---


template<typename C>
void TriggerCandProducer<C>::beginJob() {
}



template<typename C>
void TriggerCandProducer<C>::endJob() {
}

